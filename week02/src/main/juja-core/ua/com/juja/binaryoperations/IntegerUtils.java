package ua.com.juja.binaryoperations;

/**
 * Created by Artem on 01.04.2016.
 */
public class IntegerUtils {

    public static void main(String[] args) {
//        System.out.println(leftShift(6));
//        System.out.println(rightShift(24));
        System.out.println(swapBits((byte) 0b1000_0001, 0, 7));
        System.out.println((byte)0b1000_0001);
        System.out.println((byte)((0b1000_0001)));
        System.out.println("---------------");
        System.out.println((byte)(14|(-7)));
        System.out.println("---------------");
        System.out.println((byte)(0b11111111_11111111_11111111_00000110));

    }

//    Реализовать метод leftShift(int) класса IntegerUtils, который осуществляет ЦИКЛИЧЕСКИЙ СДВИГ (биты, которые “выталкивают” с одного конца – появляются на втором конце) битов влево. То есть leftShift(int) получив число 0b00000000_00000000_00000000_00000001 возвращает 0b00000000_00000000_00000000_00000010 получив число 0b10000000_00000000_00000000_00000000 возвращает 0b00000000_00000000_00000000_00000001 получив число 0b00111000_11111111_00000000_10101010 возвращает 0b01110001_11111110_00000001_01010100

    public static int leftShift(int arg) {
        int firstOne = 0b10000000_00000000_00000000_00000000;
        int addOne = 0b00000000_00000000_00000000_00000001;
        int rezult;

        if ((arg & firstOne) == firstOne) {
            rezult = (arg << 1) ^ addOne;
        } else {
            rezult = arg << 1;
        }
        return rezult;
    }

//    Реализовать метод rightShift(int) класса IntegerUtils, который осуществляет ЦИКЛИЧЕСКИЙ СДВИГ (биты, которые “выталкивают” с одного конца – появляются на втором конце) битов вправо. То есть rightShift(int) получив число 0b00000000_00000000_00000000_00000001 возвращает 0b10000000_00000000_00000000_00000000 получив число 0b10000000_00000000_00000000_00000000 возвращает 0b01000000_00000000_00000000_00000000 получив число 0b00111000_11111111_00000000_10101010 возвращает 0b00011100_01111111_10000000_01010101

    public static int rightShift(int arg) {
        int lastOne = 0b00000000_00000000_00000000_00000001;
        int addOne = 0b10000000_00000000_00000000_00000000;
        int rezult;

        if ((arg & lastOne) == lastOne) {
            rezult = (arg >>> 1) ^ addOne;
        } else {
            rezult = arg >>> 1;
        }
        return rezult;
    }

//    Реализуйте метод swapBits(b, i, j), который производит "рокировку" битов с номерами i и j,
//    то есть swapBits(0b1111_0000, 0, 6) =
//                     0b1011_0001
//    swapBits(0b0000_1000, 3, 1) =
//             0b0000_0010

    public static byte swapBits(byte b, int i, int j){

        if (i == j) {
            return b;
        } else {

            byte maskI = 0b0000_0000_0000_0001;
            byte maskJ = 0b0000_0000_0000_0001;

            if (i != 0) maskI <<= i;
            if (j != 0) maskJ <<= j;

            if (((b & maskI) == maskI) & ((b & maskJ) == maskJ)) return b;
            else {
                return (byte) (b ^ (maskI | maskJ));
            }
        }
    }

//            0 0 0 0 0 0 0
//            1 0 0 0 0 0 1
//            2 0 0 0 0 1 0
//            3 0 0 0 0 1 1
//            4 0 0 0 1 0 0
//            5 0 0 0 1 0 1
//            6 0 0 0 1 1 0
//            7 0 0 0 1 1 1

//            8 0 0 1 0 0 0
//            9 0 0 1 0 0 1
//           10 0 0 1 0 1 0
//           11 0 0 1 0 1 1
//           12 0 0 1 1 0 0
//           13 0 0 1 1 0 1
//           14 0 0 1 1 1 0
//           15 0 0 1 1 1 1

//           16 0 1 0 0 0 0
//           17 0 1 0 0 0 1


//    В Java применяется двоичное дополнение, при котором отрицательные числа представляются в результате инвертирования всех битов значения (изменения 1 на 0 и наоборот) и последующего добавления 1 к результату.
// Например, -42 представляется в результате инвертирования всех битов в двоичном представлении числа 42
//                   00101010 ( 42),

// что даёт значение 11010101, и добавления 1, что приводит к значению
//                   11010110, или -42.

// Чтобы декодировать отрицательное число, необходимо вначале инвертировать все биты, а затем добавить 1 к результату.
// Например, инвертирование значения -42,
//               или 11010110, приводит к значению
//                   00101001, или 41, после добавления 1 к которому
// мы получим 42     00101010 ( 42).

//    http://graphics.stanford.edu/~seander/bithacks.html
}
